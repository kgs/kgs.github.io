
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Geospatial analytics on Hadoop - Kamil Gorlo</title>
  <meta name="author" content="Kamil Gorlo">

  
  <meta name="description" content="Few months ago I was working on a project with a lot of geospatial data. Data was stored in HDFS, easily accessible through Hive. One of the tasks &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.kamilgorlo.com/2016/01/29/geospatial-analytics-on-hadoop">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Kamil Gorlo" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-53892992-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Kamil Gorlo</a></h1>
  
    <h2>a software engineer from Warsaw, Poland</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
  
  
  
  
<ul class="subscription">
  <li><a href="https://github.com/kgs" rel="subscribe-github" title="@kgs on GitHub">GitHub</a></li>
</ul>
  
  
  
  
<ul class="subscription">
  <li><a href="https://www.linkedin.com/in/kgorlo" rel="subscribe-linkedin" title="@kgorlo on LinkedIn">LinkedIn</a></li>
</ul>
  
  
<ul class="subscription">
  <li><a href="https://twitter.com/kgs42" rel="subscribe-twitter" title="@kgs42 on Twitter">Twitter</a></li>
</ul>
  
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="www.kamilgorlo.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
    <li><a href="/archives">Archives</a></li>
    <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">Geospatial analytics on Hadoop</h1>
      
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-29T12:32:01+01:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:32 pm</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://www.kamilgorlo.com">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>Few months ago I was working on a project with a lot of geospatial data. Data was stored in HDFS, easily accessible through Hive. One of the tasks was to analyze this data and first step was to join two datasets on columns which were geographical coordinates. I wanted some easy and efficient solution. But here is the problem - there is very little support for this kind of operations in Hadoop world.</p>

<!-- more -->


<h3>Problem</h3>

<p>Ok, so what&rsquo;s the problem actually? Let&rsquo;s say we have two datasets (represented as Hive tables). First one is very large set of geo-tagged tweets. Second one is city/place geographic boundaries. We want to match them - for every tweet we want to know it&rsquo;s location name.</p>

<p>Here are the tables (coordinates are given in simple <a href="https://en.wikipedia.org/wiki/Well-known_text">WKT format</a>):</p>

<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+-----------+------------------+---------------------------------------------+
</span><span class='line'>| tweets.id |  tweets.content  |  tweets.location_wkt                        |
</span><span class='line'>+-----------+------------------+---------------------------------------------+
</span><span class='line'>| 11        | Hi there!        | POINT(21.08448028564453 52.245122234020435) |
</span><span class='line'>| 42        | Wow, great trip! | POINT(22.928466796875 54.12185996058409)    |
</span><span class='line'>| 128       | Happy :)         | POINT(13.833160400390625 46.38046653471246) |
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure></notextile></div>




<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+-----------+-----------------+-----------------------------------------------------+
</span><span class='line'>| places.id |  places.name    |  places.boundaries_wkt                              |
</span><span class='line'>+-----------+-----------------+-----------------------------------------------------+
</span><span class='line'>| 65        | Warsaw          | POLYGON((20.76965332 52.356842,21.25305 52.3567 ... |
</span><span class='line'>| 88        | Suwa≈Çki         | POLYGON((22.890014 54.12829,22.96142 54.12829 ...   |
</span><span class='line'>| 89        | Triglav         | POLYGON((13.820114 46.383597,13.846206 46.38359 ... |
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure></notextile></div>


<p>So how to do it in Hive or Spark? Without any additional libraries or tricks we can simply do <strong>cross join</strong>, which means: compare every element from first dataset with element from the second one and then decide (using some user defined function) if there is a match.</p>

<p>But this solution has two major drawbacks:</p>

<ul>
<li>it is super slow</li>
<li>we need to write some code (UDFs) which will operate on coordinates (checks if point is in polygon, etc.)</li>
</ul>


<p>For sure there must be a better way!</p>

<h3>What are the options?</h3>

<p>There are few libraries which could help us with this task, but some of them give us only nice API (GIS Tools, Magellan) where other can do spatial joins effectively (SpatialSpark). Let&rsquo;s look at them one by one!</p>

<h3>Esri GIS Tools for Hadoop</h3>

<p>People from Esri (international company which provides Geographic Information System software) developed and open sourced <a href="https://esri.github.io/gis-tools-for-hadoop/">GIS Tools for Hadoop</a>. This toolkit contains few elements, but two most important ones are:</p>

<ul>
<li><a href="https://github.com/Esri/geometry-api-java">Esri Geometry API for JAVA</a> - it includes geometry objects, spatial operations and indexing. It can be used in standalone programs or MapReduce/Spark jobs.</li>
<li><a href="https://github.com/Esri/spatial-framework-for-hadoop">Spatial Framework for Hadoop</a> - this library includes user defined functions (UDF) that extend Hive to make spatial operations more user-friendly, internally it uses Esri Geometry API.</li>
</ul>


<p>To install this toolkit you have to simply add jars to Hive classpath and then register needed UDFs. You can find more detailed tutorial <a href="https://github.com/Esri/gis-tools-for-hadoop/tree/master/samples/point-in-polygon-aggregation-hive">here</a>.</p>

<p>Finally you will be able to run Hive query like this:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">places</span><span class="p">,</span> <span class="n">tweets</span>
</span><span class='line'>    <span class="k">WHERE</span> <span class="n">ST_Intersects</span><span class="p">(</span>
</span><span class='line'>               <span class="n">ST_GeomFromText</span><span class="p">(</span><span class="n">places</span><span class="p">.</span><span class="n">boundaries_wkt</span><span class="p">),</span>
</span><span class='line'>               <span class="n">ST_GeomFromText</span><span class="p">(</span><span class="n">tweets</span><span class="p">.</span><span class="n">location_wkt</span><span class="p">)</span>
</span><span class='line'>          <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>


<p>If you know <a href="http://postgis.net/">Postgis</a> (GIS extension for PostgreSQL) this will look very familiar to you, because syntax is similar. Unfortunately these kind of queries are very inefficient in Hive. Hive will do cross join and it means that for big datasets computations will last for unacceptable amount of time.</p>

<h4>Spatial binning</h4>

<p>There is small trick which can help a bit with efficiency problem when doing spatial joins. It&rsquo;s called spatial binning. The idea is to divide our space with points and polygons to numbered rectangular blocks. Then, for every object (like point or polygon) we assign corresponding block number to it.</p>

<p>Here is (hopefully) helpful image:</p>

<p><img class="center" src="/images/binning.png"></p>

<p>In the above example, space was divided into 8 blocks, there are some empty blocks and some with many points. For example there are 5 points which will get number 4 as their <strong>BIN ID</strong>.</p>

<p>Going back to our example with tweets (represented as points) and places (represented as polygons) we can assign BIN IDs to both of them and then join them block by block, calling UDFs only for objects with the same BIN ID. It will be more efficient because we will only do cross joins for significantly smaller sets (one block), but many of them (as many as total number of blocks).</p>

<p>Of course, there are some corner cases (like borders of blocks), but general idea is as explained. If you want to read more about this technique, please visit <a href="https://github.com/Esri/gis-tools-for-hadoop/wiki/Aggregating-CSV-Data-%28Spatial-Binning%29">Esri Wiki</a>.</p>

<h3>Magellan</h3>

<p>Second solution I&rsquo;d like to show you is based on Apache Spark - more powerful (but also a bit more complicated) tool than Apache Hive.</p>

<p>Magellan is open source library for geospatial analytics that uses Spark as underlying engine. Hortonworks published blog post about it <a href="http://hortonworks.com/blog/magellan-geospatial-analytics-in-spark/">here</a> and as far as I understand this library was created by one of the company&rsquo;s engineers.</p>

<p>It is in very early stage of development and as of this date it gives us only nice API and unfortunately not so efficient algorithms for spatial joins.</p>

<p>Here is sample code in Spark (using Scala) to do spatial join using <em>intersects</em> predicate:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// points and polygons are DataFrames of types magellan.{Point, Polygon}</span>
</span><span class='line'><span class="n">points</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">polygons</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="n">$</span><span class="s">&quot;point&quot;</span> <span class="n">intersects</span> <span class="n">$</span><span class="s">&quot;polygon&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>


<p>It is definitely library to watch, but as for now it&rsquo;s not so useful in my opinion, mainly because it&rsquo;s lacking features. If you want to know more, please visit Magellan <a href="https://github.com/harsha2010/magellan">github page</a>.</p>

<h3>SpatialSpark</h3>

<p>Third solution and also my favourite one (maybe because I contributed to it a bit ;)) is <a href="http://simin.me/projects/spatialspark/">SpatialSpark</a>. It&rsquo;s another library that is using Apache Spark as underlying engine. For low-level spatial functions and data structures (like indexes) it is using great and well tested <a href="http://tsusiatsoftware.net/jts/main.html">JTS</a> library.</p>

<p>It&rsquo;s selling feature is that it can do spatial joins efficiently. It supports two kind of joins:</p>

<ul>
<li><strong>broadcast spatial join</strong> - it&rsquo;s designed for joining big dataset with smaller one efficiently. Smaller data set is converted to index (R-tree) and kept in memory. Algorithm simply iterates (in distributed way) over big dataset and queries index from the other set efficiently.</li>
<li><strong>partitioned spatial join</strong> - it&rsquo;s designed for joining two big datasets and uses similar idea to binning, but it&rsquo;s more complicated and more efficient. Sets are divided into small pieces (you can choose what algorithm could be responsible for this operation - there are few implemented to make splits as equal as possible depending on data characteristics) and then each small piece is processed individually (using R-trees).</li>
</ul>


<p>Here is sample Spark code snippet to do broadcast spatial join for our case with tweets and places:</p>

<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// create RDD with pairs (id, location_geometry) for tweets</span>
</span><span class='line'><span class="k">val</span> <span class="n">leftGeometryById</span> <span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">Long</span>, <span class="kt">Geometry</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">tweets</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">toLong</span><span class="o">,</span> <span class="k">new</span> <span class="nc">WKTReader</span><span class="o">().</span><span class="n">read</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">location_wkt</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// right geometry (places) has to be relatively small for broadcast join</span>
</span><span class='line'><span class="k">val</span> <span class="n">rightGeometryById</span> <span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">Long</span>, <span class="kt">Geometry</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">places</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">toLong</span><span class="o">,</span> <span class="k">new</span> <span class="nc">WKTReader</span><span class="o">().</span><span class="n">read</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">boundaries_wkt</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// we get matching ids from tweets and places</span>
</span><span class='line'><span class="k">val</span> <span class="n">matchedIdPairs</span> <span class="k">:</span> <span class="kt">RDD</span><span class="o">[(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">BroadcastSpatialJoin</span><span class="o">(</span><span class="n">sparkContext</span><span class="o">,</span> <span class="n">leftGeometryById</span><span class="o">,</span> <span class="n">rightGeometryById</span><span class="o">,</span>
</span><span class='line'>                       <span class="nc">SpatialOperator</span><span class="o">.</span><span class="nc">Intersects</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>


<p>Unfortunately there are also drawbacks. API is not so clean and easy to use. You have to use classes as shown in example above or use command line tools that expect data in exactly one format (more details on <a href="https://github.com/syoummer/SpatialSpark">github page</a>). Even bigger problem is that development of SpatialSpark is not so active. Hopefully it will change in future.</p>

<h3>Other options</h3>

<p>If you can and want to keep data in some other systems than Hadoop there are few possibilities to do spatial joins. Of course not all of them have the same set of features, but all of them implement some kind of geospatial search that could be useful when dealing with geographic data.</p>

<p>Here are the links:</p>

<ul>
<li><a href="https://github.com/Stratio/cassandra-lucene-index">Cassandra with Lucene index</a> - you can keep data in Cassandra and use secondary index that integrates Lucene features (geospatial search is one of many)</li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/geohashes.html">Elasticsearch (with Geohashes)</a> - geohashes are a way of encoding latitude and longitude to string, you can keep and query them with Elasticsearch</li>
<li><a href="http://www.geomesa.org/">GeoMesa</a> - it&rsquo;s whole geospatial distributed database built on top of Apache Accumulo</li>
<li><a href="https://ngageoint.github.io/geowave/">GeoWave</a> - very similar to GeoMesa, but a bit newer</li>
</ul>


<h3>Summary</h3>

<p>As you can probably see now, there is no big choice in terms of spatial joins when we have our data in Hadoop. If you want to do things efficiently then <a href="http://simin.me/projects/spatialspark/">SpatialSpark</a> is the only option IMHO. If you want something easier to use then <a href="https://esri.github.io/gis-tools-for-hadoop/">Esri GIS Tools for Hadoop</a> is the way to go, but unfortunately this only makes sense for really small datasets.</p>

<p>That&rsquo;s all! Hopefully you&rsquo;ve enjoyed this post. Feel free to comment below if you have any questions or suggestions.</p>
</div>


  <footer>
    <p class="meta">
      
  



  <span class="byline author vcard">Authored by <span class="fn">
  
    Kamil Gorlo
  
  </span></span>


      




<time class='entry-date' datetime='2016-01-29T12:32:01+01:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:32 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/categories/hadoop/'>hadoop</a>, <a class='category' href='/categories/spark/'>spark</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/2014/08/16/why-blog/" title="Previous Post: Why blog?">&laquo; Why blog?</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


</div>

<aside class="sidebar">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Kamil Gorlo -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'kamilgorlo';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://www.kamilgorlo.com/2016/01/29/geospatial-analytics-on-hadoop/';
        var disqus_url = 'http://www.kamilgorlo.com/2016/01/29/geospatial-analytics-on-hadoop/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>














</body>
</html>
